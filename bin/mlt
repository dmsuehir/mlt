#!/usr/bin/env python
"""mlt.
Usage:
  mlt (-h | --help)
  mlt --version
  mlt [-v] add registry <registry_name> <registry_git_url>
  mlt [-v] remove registry <registry_name>
  mlt [-v] update
  mlt [-v] init [--template=<template>] <name>
  mlt [-v] build [--watch]
  mlt [-v] deploy
  mlt [-v] undeploy
  mlt [-v] list (template | templates)

Options:
  --template=<template>           Template name for app
                                  initialization [default: hello-world].
  -v                              Turn on verbose logging for mlt.
"""
import sys
import shutil
import os
import uuid
import json
import time
import logging
import os.path
import subprocess
import progressbar
from tabulate import tabulate

from appdirs import user_cache_dir
from termcolor import colored
from docopt import docopt
from string import Template
from subprocess import call, check_output, Popen, PIPE, STDOUT
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler
from threading import Timer

log = logging.getLogger(__name__)

def duration_progress(activity, duration, is_done):
  def progress(activity, iterations=100):
      bar = progressbar.ProgressBar(widgets=[activity, ' ', progressbar.Bar(), ' (', progressbar.ETA(), ') ', ])
      return bar(range(iterations))

  if duration is not None:
    iterations = 100
    time_per_iteration = float(duration) / float(iterations)

    bar = progress(activity, iterations)
    cursor = 0
    for cursor in range(iterations):
        bar.next()
        time.sleep(time_per_iteration)

        # If done early.
        if is_done():
          bar.update(100)
          break

  if not is_done():
      # if still not done.
      bar = progressbar.ProgressBar(widgets=[activity, ' ', progressbar.RotatingMarker(), ' (', progressbar.Timer(), ') ', ], max_value=progressbar.UnknownLength)
      i = 0
      while not is_done():
          bar.update(i)
          i += 1

  print("")

class EventHandler:
  def __init__(self, args):
    self.args = args
    self.last_changed = time.time()
    self.dirty = False
    self.timer = None

  def dispatch(self, event):
    if event.src_path == "./.git" or event.src_path == "./":
      return

    is_ignored = call(["git", "check-ignore", event.src_path], stdout=open(os.devnull, 'wb')) == 0
    if is_ignored:
      return

    if self.timer:
      self.timer.cancel()

    def timer_triggered():
      do_build(self.args)

    self.timer = Timer(3, timer_triggered)
    self.timer.start()


def build(args):
  if args['--watch']:
    event_handler = EventHandler(args)
    observer = Observer()
    observer.schedule(event_handler, './', recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)

    except KeyboardInterrupt:
        observer.stop()
    observer.join()

  else:
    do_build(args)

def do_build(args):
  last_build_duration = None
  if os.path.isfile('.build.json'):
    status = json.load(open('.build.json'))
    last_build_duration = status['last_build_duration']

  started_build_time = time.time()

  config = json.load(open('.studio.json'))
  app_name = config['name']
  namespace = config['namespace']

  container_id = str(uuid.uuid4())
  container_name = app_name + ":" + container_id

  print("Starting build %s" % container_name)

  # Add bar
  build_process = Popen(["docker", "build", "-t", container_name, "."], stdout=PIPE, stderr=STDOUT)
  def build_is_done():
    return build_process.poll() is not None
  duration_progress('Building', last_build_duration, build_is_done)
  if build_process.poll() != 0:
    print(colored(build_process.communicate()[0], 'red'))
    sys.exit(1)

  built_time = time.time()

  # Write last container to file
  with open('.build.json', 'w') as f:
    f.write(json.dumps({
      "last_container": container_name,
      "last_build_duration": built_time - started_build_time
    }))

  print("Built %s" % container_name)


def do_push(args):
  last_push_duration = None
  if os.path.isfile('.push.json'):
    status = json.load(open('.push.json'))
    last_push_duration = status['last_push_duration']

  container_name = None
  if os.path.isfile('.build.json'):
    status = json.load(open('.build.json'))
    container_name = status['last_container']
  else:
    print("Need to run build before pushing")
    sys.exit(1)

  config = json.load(open('.studio.json'))
  remote_container_name = "gcr.io/" + config['gceProject'] + "/" + container_name

  started_push_time = time.time()
  run(["docker", "tag", container_name, remote_container_name])
  push_process = Popen(["gcloud", "docker", "--", "push", remote_container_name], stdout=PIPE, stderr=PIPE)
  def push_is_done():
    return push_process.poll() is not None
  duration_progress('Pushing ', last_push_duration, push_is_done)
  if push_process.poll() != 0:
    print(colored(push_process.communicate()[0], 'red'))
    sys.exit(1)

  pushed_time = time.time()

  with open('.push.json', 'w') as f:
    f.write(json.dumps({
      "last_remote_container": remote_container_name,
      "last_push_duration": pushed_time - started_push_time
    }))

  print("Pushed to %s" % remote_container_name)


def deploy(args):
  if not os.path.isfile('.build.json'):
    do_build(args)

  do_push(args)

  config = json.load(open('.studio.json'))
  app_name = config['name']
  namespace = config['namespace']

  status = json.load(open('.push.json'))
  remote_container_name = status['last_remote_container']
  run_id = str(uuid.uuid4())

  print("Deploying %s" % remote_container_name)

  # Write new container to deployment
  for filename in os.listdir("k8s-templates"):
    with open('k8s-templates/' + filename) as f:
      deployment_template = f.read()
      s = Template(deployment_template)
      out = s.substitute(image=remote_container_name, app=app_name, run=run_id)

      with open('k8s/' + filename,'w') as f:
        f.write(out)

    ensure_namespace_exists(namespace)
    run(["kubectl", "--namespace", namespace, "apply", "-R", "-f", "k8s"])

    print("\nInspect created objects by running:\n  $ kubectl get --namespace=%s all\n" % namespace)


def undeploy(args):
  if not os.path.isfile('.studio.json'):
    print("run `mlt undeploy` within a project directory")
    sys.exit(1)

  config = json.load(open('.studio.json'))
  namespace = config['namespace']
  run(["kubectl", "--namespace", namespace, "delete", "-f", "k8s"])


def find_template(template_name):
  """
  Returns the directory that `template_name` is located in.
  
  If `template_name` does not contain a `/`, then the template is searched for in the default
  template registry. Otherwise the name is assumed to be of the `<registry_name>/<template_name>
  form. ValueError is raised if template is not found.
  """
  registry_directory = user_cache_dir('mlt', 'intel')
  if template_name.find('/') == -1:
    registry_name = 'mlt-registry'
  else:
    registry_name = template_name[:slash_index]
    template_name = template_name[slash_index:]
  if registry_name not in os.listdir(registry_directory):
    raise ValueError("Could not find registry {} in default registry".format(registry_name))
  if template_name not in os.listdir(os.path.join(registry_directory, registry_name)):
    raise ValueError("Could not find template {} in registry {}".format(template_name, registry_name))
  template_dir = os.path.join(registry_directory, registry_name, template_name)
  return template_dir


def init(args):
  template_path = find_template(args['--template'])
  
  # Find where this template is located
  app_name = args["<name>"]
  try:
    shutil.copytree(template_path, app_name)

    raw_project_bytes = check_output(["gcloud", "config", "list", "--format", "value(core.project)"])
    project = raw_project_bytes.decode("utf-8").strip()

    with open(app_name + '/.studio.json','w') as f:
      f.write('''
{
  "name": "%s",
  "namespace": "%s",
  "gceProject": "%s"
}
''' % (app_name, app_name, project))

    # Initialize new git repo in the project dir and commit initial state.
    run(["git", "init", app_name])
    run(["git", "add", "."], cwd=app_name)
    print(run(["git", "commit", "-m", "Initial commit."], cwd=app_name))

  except OSError as exc:
    if exc.errno == 17:
      print("Directory '%s' already exists: delete before trying to initialize new application" % app_name)
    else:
      print(exc)


def ensure_namespace_exists(ns):
  exit_code = call(["kubectl", "get", "namespace", ns], stdout=open(os.devnull, 'wb'), stderr=open(os.devnull, 'wb'))
  if exit_code is not 0:
    run(["kubectl", "create", "namespace", ns])

def run(command, cwd=None):
  try:
    output = check_output(command, cwd=cwd).decode("utf-8")
  except subprocess.CalledProcessError as e:
    print(e.output)
    sys.exit(1)

  return output

def templates_list(args):
  registry_directory = user_cache_dir('mlt', 'intel')

  table = []
  for registry in os.listdir(registry_directory):
    for registry_repo in os.listdir(os.path.join(registry_directory, registry)):
      if registry_repo == '.git' or not os.path.isdir(os.path.join(registry_directory, registry, registry_repo)):
        continue
      description = ''
      readme_file = registry_directory + "/" + registry_repo + "/README.md"
      if os.path.isfile(readme_file):
        with open(readme_file) as f:
          lines = f.readlines()
          for line in lines:
            if line[0] == '#' or line[0] == '\n':
              continue
            description = line
            break

      table.append([registry_repo, description])

  print(tabulate(table, headers=['Template', 'Description'], tablefmt="simple"))

  
def update_template_registries():
  """ Updates template registries with a `git pull` """
  registry_directory = user_cache_dir('mlt', 'intel')

  for registry in os.listdir(registry_directory):
    repo_dir = os.path.join(registry_directory, registry)
    if registry == '.git' or not os.path.isdir(repo_dir):
      continue
    log.info("Updating registry %s in %s", registry, repo_dir)
    run(['git', 'fetch'], cwd=repo_dir)


def init_template_registry():
  # TODO: switch to non-SSH url once mlt-registry is public
  # add_template_registry('https://github.com/NervanaSystems/mlt-registry.git')
  add_template_registry('git@github.com:NervanaSystems/mlt-registry.git')


def add_template_registry(registry_url, registry_name=None):
  """ Add new registry using an optional user specified registry name as an alias """
  cache_dir = user_cache_dir('mlt','intel')
  if registry_name is None:
    registry_name = registry_url.split('/')[-1].replace('.git', '')
  if not os.path.isdir(cache_dir):
    os.makedirs(cache_dir)
  if not os.path.isdir(os.path.join(cache_dir, registry_name)):
    log.info("Cloning registry %s from %s", registry_name, registry_url)
    run(['git', 'clone', registry_url, registry_name], cwd=cache_dir)


def remove_template_registry(registry_name):
  """ Remove template registry using users alias """
  dirname = os.path.join(user_cache_dir('mlt','intel'), registry_name)
  if not os.path.isdir(dirname):
    log.error("Could not find template registry named %s when attempting deletion.",
      registry_name)
  log.info("Removing registry %s", registry_name)
  shutil.rmtree(dirname)


def main():
    args = docopt(__doc__, version="ML Container Templates v0.0.1")

    if args['-v']:
      level = logging.DEBUG
    else:
      level = logging.INFO
    logging.basicConfig(level=level, format='%(levelname)s: %(message)s')

    if args["add"]:
      add_template_registry(args['<registry_git_url>'], args['<registry_name>'])

    if args["init"]:
      init_template_registry()
      init(args)

    if args["update"]:
      update_template_registries()

    if args["remove"] and args["registry"]:
      remove_template_registry(args['<registry_name>'])

    if args["build"]:
      if not os.path.isfile('.studio.json'):
        print("`mlt build` requires you to be in a `mlt init` built directory.")
        sys.exit(1)

      build(args)

    if args["deploy"]:
      if not os.path.isfile('.studio.json'):
        print("`mlt build` requires you to be in a `mlt init` built directory.")
        sys.exit(1)

      deploy(args)

    if (args["template"] or args["templates"]) and args["list"]:
      init_template_registry()
      templates_list(args)

    if args["undeploy"]:
      undeploy(args)

main()
